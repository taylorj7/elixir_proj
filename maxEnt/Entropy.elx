defmodule Entropy do
    def count_unique_words(s)  do
        (String.split(s)
            |> Enum.reduce([[],0],
                fn (elem,[a1,a2]) ->
                    if Enum.any?(a1, fn(e) -> e == elem end) do
                        [a1,a2]
                    else
                        [a1 ++ [elem], a2 + 1]
                    end
                end))
    end
    def count_appearances(s,k) do
        (String.split(s)
            |> Enum.reduce(0,
                fn (elem,a2) ->
                    if elem == k do
                        a2 + 1
                    else
                        a2
                    end
                end))
    end
    def words(s) do
        (String.split(s)
            |> Enum.reduce(0,
                fn (_,a2) ->
                    a2 + 1
                end))
    end
    # Crap
    def weight(s,k) do
        count_appearances(s,k)/words(s)
    end
    # Crap
    def weight_by_class(c,k) do
        Enum.reduce(c, 0,
            fn(str, v) -> weight(str, k) + v end)/length(c)
    end
    # Crap
    def overall_weights(classes, k) do
        classes
            |> Enum.map(fn(class) -> weight_by_class(class, k) end)
    end
    def add(ls, []) do
        ls
    end
    def add([], ls) do
        ls
    end
    def add([h|t], [h2|t2]) do
        [h+h2|add(t,t2)]
    end
    def combine_many(results) do
        results
            |> Enum.map(fn(result) ->
                    Enum.map(result, fn(val) -> 
                        val/length(results) end) end)
            |> Enum.reduce([],
                fn(temp,params)->add(temp,params) end)
    end
    def classify(doc, classes, lambdas, features) do
        c = calc_constant(doc,classes,lambdas,features)
        i = for j <- 0..length(classes), do: j
        classInd = List.zip(classes, i)
        [_, class] = classInd
                    |> parallelEnum.preduce(fn([class, k]) ->
                                             [:math.pow(2.71828, feature_calc(doc,class,lambdas,features))/c, k] 
                                                end,
                                            fn([val,class],[maxval,maxclass]) ->
                                                if val > maxval do
                                                    [val, class]
                                                else
                                                    [maxval, maxclass]
                                                end
                                                end,
                                            [-10,0])
        class
    end
    def calc_constant(doc, classes, lambdas, features) do
        classes
            |> parallelEnum.preduce(fn(class) -> :math.pow(2.71828,feature_calc(doc,class,lambdas,features)) end, 
                                    fn(x,a) -> x + a end, 
                                    0)
    end
    def feature_calc(doc,class,lambdas,features) do
        List.zip(lambdas,features)
            |> Enum.reduce(0, fn([lambda,feat], Accum) -> lambda*feat.(doc,class) + Accum end)
    end
end
defmodule Utility do
    def natLog(x) do
        :math.log10(x)/:math.log10(2.719)
    end
end
defmodule parallelEnum do
    def pmap(collection, fun) do
        me = self
        collection
            |> Enum.map(fn (elem) ->
                spawn_link fn -> (send me, { self, fun.(elem) }) end end) 
            |> Enum.map(fn (pid) ->
                receive do { ^pid, result } -> result end
                end)
    end
    def preduce(collection, fun, join, start) do
        me = self
        collection
            |> Enum.map(fn (elem) ->
                spawn_link fn -> (send me, { self, fun.(elem) }) end end) 
            |> Enum.map(fn (pid) ->
                receive do { ^pid, result } -> result end
                end)
            |> Enum.reduce(start, fn(val, a) ->
                join.(val, a)
                end)
    end
end